/*
 * --- AUTO-GENERATED DOCSTRING ---
 * This docstring is automatically generated by Agent Docstrings.
 * Do not modify this block directly.
 * 
 * Classes/Functions:
 *   - Functions:
 *     - func main() (line 50)
 *     - func parseGoCode(source string) (*ParseResult, error) (line 71)
 *     - func buildFunctionSignature(fn *ast.FuncDecl) string (line 141)
 *     - func buildMethodSignature(fn *ast.FuncDecl) string (line 152)
 *     - func buildInterfaceMethodSignature(method *ast.Field) string (line 170)
 *     - func buildParameterList(params *ast.FieldList) string (line 187)
 *     - func buildResultList(results *ast.FieldList) string (line 215)
 *     - func getTypeString(expr ast.Expr) string (line 241)
 *     - func getExprString(expr ast.Expr) string (line 282)
 *     - func joinStrings(strs []string, sep string) string (line 293)
 * --- END AUTO-GENERATED DOCSTRING ---
 */

package main

import (
	"encoding/json"
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"io"
	"os"
)

// SignatureInfo represents a function or method signature with line number
type SignatureInfo struct {
	Signature string `json:"signature"`
	Line      int    `json:"line"`
}

// ClassInfo represents a struct or interface with its methods
type ClassInfo struct {
	Name         string          `json:"name"`
	Line         int             `json:"line"`
	Methods      []SignatureInfo `json:"methods"`
	InnerClasses []ClassInfo     `json:"inner_classes"`
}

// ParseResult contains the parsing results
type ParseResult struct {
	Classes   []ClassInfo     `json:"classes"`
	Functions []SignatureInfo `json:"functions"`
}

func main() {
	// Read Go source code from stdin
	input, err := io.ReadAll(os.Stdin)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error reading input: %v\n", err)
		os.Exit(1)
	}

	result, err := parseGoCode(string(input))
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error parsing Go code: %v\n", err)
		os.Exit(1)
	}

	// Output JSON result
	if err := json.NewEncoder(os.Stdout).Encode(result); err != nil {
		fmt.Fprintf(os.Stderr, "Error encoding JSON: %v\n", err)
		os.Exit(1)
	}
}

func parseGoCode(source string) (*ParseResult, error) {
	fset := token.NewFileSet()
	file, err := parser.ParseFile(fset, "", source, parser.ParseComments)
	if err != nil {
		return nil, err
	}

	result := &ParseResult{
		Classes:   []ClassInfo{},
		Functions: []SignatureInfo{},
	}

	// Extract function declarations
	ast.Inspect(file, func(n ast.Node) bool {
		switch node := n.(type) {
		case *ast.FuncDecl:
			pos := fset.Position(node.Pos())
			
			// Build function signature
			var signature string
			if node.Recv != nil {
				// Method with receiver
				signature = buildMethodSignature(node)
			} else {
				// Regular function
				signature = buildFunctionSignature(node)
			}

			result.Functions = append(result.Functions, SignatureInfo{
				Signature: signature,
				Line:      pos.Line,
			})

		case *ast.TypeSpec:
			// Handle struct and interface types
			pos := fset.Position(node.Pos())
			
			switch typeNode := node.Type.(type) {
			case *ast.StructType:
				// For structs, we don't collect methods here since they're defined separately
				// We could collect them if needed, but Go methods are typically defined outside the struct
				_ = typeNode
			case *ast.InterfaceType:
				// For interfaces, collect method signatures
				methods := []SignatureInfo{}
				for _, method := range typeNode.Methods.List {
					if len(method.Names) > 0 {
						methodPos := fset.Position(method.Pos())
						methodSig := buildInterfaceMethodSignature(method)
						methods = append(methods, SignatureInfo{
							Signature: methodSig,
							Line:      methodPos.Line,
						})
					}
				}
				
				result.Classes = append(result.Classes, ClassInfo{
					Name:         node.Name.Name,
					Line:         pos.Line,
					Methods:      methods,
					InnerClasses: []ClassInfo{}, // Go doesn't have nested types in the same way
				})
			}
		}
		return true
	})

	return result, nil
}

func buildFunctionSignature(fn *ast.FuncDecl) string {
	signature := fmt.Sprintf("func %s", fn.Name.Name)
	signature += buildParameterList(fn.Type.Params)
	
	if fn.Type.Results != nil {
		signature += " " + buildResultList(fn.Type.Results)
	}
	
	return signature
}

func buildMethodSignature(fn *ast.FuncDecl) string {
	signature := "func "
	
	// Add receiver
	if fn.Recv != nil && len(fn.Recv.List) > 0 {
		signature += buildParameterList(fn.Recv)
	}
	
	signature += fmt.Sprintf(" %s", fn.Name.Name)
	signature += buildParameterList(fn.Type.Params)
	
	if fn.Type.Results != nil {
		signature += " " + buildResultList(fn.Type.Results)
	}
	
	return signature
}

func buildInterfaceMethodSignature(method *ast.Field) string {
	if len(method.Names) == 0 {
		return ""
	}
	
	signature := method.Names[0].Name
	
	if funcType, ok := method.Type.(*ast.FuncType); ok {
		signature += buildParameterList(funcType.Params)
		if funcType.Results != nil {
			signature += " " + buildResultList(funcType.Results)
		}
	}
	
	return signature
}

func buildParameterList(params *ast.FieldList) string {
	if params == nil || len(params.List) == 0 {
		return "()"
	}
	
	signature := "("
	paramStrs := []string{}
	
	for _, param := range params.List {
		paramType := getTypeString(param.Type)
		
		if len(param.Names) == 0 {
			// Unnamed parameter
			paramStrs = append(paramStrs, paramType)
		} else {
			// Named parameters
			for _, name := range param.Names {
				paramStrs = append(paramStrs, fmt.Sprintf("%s %s", name.Name, paramType))
			}
		}
	}
	
	signature += joinStrings(paramStrs, ", ")
	signature += ")"
	
	return signature
}

func buildResultList(results *ast.FieldList) string {
	if results == nil || len(results.List) == 0 {
		return ""
	}
	
	resultStrs := []string{}
	
	for _, result := range results.List {
		resultType := getTypeString(result.Type)
		
		if len(result.Names) == 0 {
			resultStrs = append(resultStrs, resultType)
		} else {
			for _, name := range result.Names {
				resultStrs = append(resultStrs, fmt.Sprintf("%s %s", name.Name, resultType))
			}
		}
	}
	
	if len(resultStrs) == 1 {
		return resultStrs[0]
	}
	
	return "(" + joinStrings(resultStrs, ", ") + ")"
}

func getTypeString(expr ast.Expr) string {
	switch t := expr.(type) {
	case *ast.Ident:
		return t.Name
	case *ast.StarExpr:
		return "*" + getTypeString(t.X)
	case *ast.ArrayType:
		if t.Len == nil {
			return "[]" + getTypeString(t.Elt)
		}
		return fmt.Sprintf("[%s]%s", getExprString(t.Len), getTypeString(t.Elt))
	case *ast.SelectorExpr:
		return getTypeString(t.X) + "." + t.Sel.Name
	case *ast.MapType:
		return fmt.Sprintf("map[%s]%s", getTypeString(t.Key), getTypeString(t.Value))
	case *ast.ChanType:
		direction := ""
		switch t.Dir {
		case ast.SEND:
			direction = "chan<- "
		case ast.RECV:
			direction = "<-chan "
		default:
			direction = "chan "
		}
		return direction + getTypeString(t.Value)
	case *ast.FuncType:
		sig := "func" + buildParameterList(t.Params)
		if t.Results != nil {
			sig += " " + buildResultList(t.Results)
		}
		return sig
	case *ast.InterfaceType:
		return "interface{}"
	case *ast.StructType:
		return "struct{}"
	default:
		return "unknown"
	}
}

func getExprString(expr ast.Expr) string {
	switch e := expr.(type) {
	case *ast.BasicLit:
		return e.Value
	case *ast.Ident:
		return e.Name
	default:
		return "..."
	}
}

func joinStrings(strs []string, sep string) string {
	if len(strs) == 0 {
		return ""
	}
	if len(strs) == 1 {
		return strs[0]
	}
	
	result := strs[0]
	for i := 1; i < len(strs); i++ {
		result += sep + strs[i]
	}
	return result
} 